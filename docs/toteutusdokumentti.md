# Sovelluksen toteutus
Sovellus on toteutettu ilman laajojen kielimallien käyttöä.

### Sovelluksen rakenne ja toiminta
Sovellus on graafisen käyttöliittymän (GUI) omaava tieteellinen laskin, jolle voidaan antaa syötteitä myös tietokoneen näppäimistön avulla. Käyttäjän infix-notaatiossa antama laskutoimitus annetaan käyttöliittymästä merkkijonona laskutoimituksista vastaavalle luokalle, joka hyödyntää validointi-luokkaa syötteen validoinnissa. Syötteen mukana annetaan käyttäjän GUI:ssa määrittelemä laskennan tarkkuus (desimaalien lukumäärä tuloksessa). Validointi suoritetaan kahdessa osassa. Ensin syöte validoidaan sen suhteen onko siinä oikeat tokenit oikeassa järjestyksessä (esim. että funktioille annetaan oikea määrä argumentteja) ja evaluoinnin jälkeen validoidaan onko evaluointi onnistunut. Tämä siksi, että esim. nollalla jakamisesta johtuvaa virhettä ei voida mielekkäästi tunnistaa ennen evaluointia, koska jakajana saattaa olla monimutkainen laskutoimitus. Jos validoinnissa huomataan virhe, laskin-luokka saa validointi-luokalta virheilmoituksen sisältävän merkkijonon, jonka laskin-luokka antaa eteenpäin GUI-luokalle. Jos validoinnissa ei löydetä virheitä, validointi-luokka antaa tyhjän merkkijonon laskin-luokalle, joka sitten palauttaa GUI-luokalle merkkijonomuotoisen syötteen, johon on lisätty " = X --> A", jossa X on saatu tulos ja A on muuttuja (--> A lisätään vain jos tulos talletetaan muuttujaan). Laskin-luokalla on results-muuttuja, johon saatu tulos talletetaan mahdollista muuttujaan tallettamista varten.

Sovellus hyödyntää validoinnissa ja laskutoimitusten evaluoinnissa sitä, että kullekin syötteen merkille on olemassa uniikki unicode-kokonaisluku. Tällöin on mahdollista tarkistaa että onko syötteen merkki esim. numero tai kirjain yksinkertaisilla vertailuoperaatioilla, sillä esim. numeroiden unicode-luvut ovat peräkkäisiä, eikä esim. tarvitse tarkistaa looppien avulla kuuluuko kyseinen syötteen merkki merkkijonoon "0123456789" tai tarkistaa isdigit() -funktiolla onko kyseessä kokonaisluku. Muunnokset merkkien ja unicode-lukujen välillä tosin monimutkaistaa merkittävästi sovelluksen rakennetta. Lisäksi tällä saatu hyöty algoritmien nopeudessa jää melko pieneksi, koska loopattavat merkkijonot olisivat olleet suhteellisen pieniä. Saatuaan merkkijonomuotoisen syötteen, laskin-luokka muuttaa sen listaksi syötteen merkkien unicode-lukuja. Sitten laskin-luokka käy läpi kyseisen listan ja tekee sen avulla listan listoja, joissa kukin lista sisältää tokenin merkkien unicode-luvut. Laskimen shunting yard -algoritmi tekee tämän listojen listan avulla dequen, joka sisältää tokenien kokonaislukulistat postfix-notaatiossa. Laskin muuttaa sitten tämän dequen listat merkkijonomuotoon tai Decimal-olioiksi (jos token on muuttuja, vakio tai luku). Laskin evaluoi tämän dequen, muuttaa tuloksen oikeaan tarkkuuteen käyttäjän antaman arvon mukaisesti. Kyseinen tulos tallennetaan laskimen results-muuttujaan, josta tämä deque myöhemmin (jos käyttäjä on niin määrittänyt GUI:ssa) tallennetaan muuttujat ja niiden arvot sisältävään dictionaryyn.

### Suorituskyky
Sovelluksen algoritmeilla on seuraavat aikavaativuudet: